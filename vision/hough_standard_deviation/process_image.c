/*process_image.c - The heart and soul of sdsp vision
 *
 *Author: R. Brooks Stephenson
 *Date: 7.1.2009
 *
 */






//Include standard libraries
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

//Include custom header
#include "bitmap.h"


//Defines to clean up code
#define DEVIATION 0x20
#define YES 1
#define NO 0
#define PI 3.1415927f

#define REDUCED 0
#define ALL 1


//Defines to adjust the performace of the hough transform.
#define INTENSITY_ADDED 5		//Defalt is 5, this makes the hough transfrom "brighter".  Note: changing this value will result in a possible need to change the "hough_threshold" values as well.
#define SAMPLES_PER_UNIT 8.0f	//Default is 8.0f, making this smaller will increase the speed of the transform, but will decrease its accuracy.  At 1.0f, you will have angles confined to 360 integer angles (i.e. 15 degrees instead of 15.3 degrees).
#define HOUGH_ANGLE 180			//Default is 180







//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Debug define, comment this out to hide debugging printf's													//
//#define DEBUG 1																							//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Resolution define: Determines the resolution of the hough transform.  When set to "HIGH", the hough		//
//transform will not look as pretty, but will render better hough lines.  When set to "LOW", the			//
//transfrom will look nicer, but there will be a slight degradation in hough line quality.					//
//NOTE:	Chaning the method of calculation will affect the number of hough lines displayed if you do			//
//		not modify the rest of the hough parameters (i.e. the #defines and "hough_transform" values			//
//#define HIGH																								//
#define LOW																									//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////







//---Globals---//

//Number of objects so far
unsigned int num_objects;

//---The main image processing function by which all other processes are called---//
int process_image(IMAGE* input_image, IMAGE* output_image, int numberToFind)
{
	
	
	//---Local Variables---//
	
	//General purpose variables
	int i,j,k;
	
	//Generic pixel for holding temporary 
	unsigned char average;
	
	//max value of hough image
	SINGLE_PIXEL* maxValue;
	
	//Hough Transform image
	IMAGE* hough_image;
	
	//Array of objects
	OBJECT* objects;
	
	//General threshold
	SINGLE_PIXEL* threshold;
	
	//Hough Treshold
	SINGLE_PIXEL hough_threshold;
	
	//Deviation variable (not implimented)
	SINGLE_PIXEL deviation;
	
	
	
	
	
	
	
	//---The order of these operations is best suited to find lines in images---//
	
	//Allocate memory for maxValue (used to normalize the image)
	maxValue = (SINGLE_PIXEL*)calloc(1, sizeof(SINGLE_PIXEL));
	
	//Set maxValue to zero
	maxValue->red = 0;
	maxValue->green = 0;
	maxValue->blue = 0;
	
	//Set the hough threshold (the minimum pixel value it considers to be of importance)
	hough_threshold.red = 0x50;
	hough_threshold.green = 0x50;
	hough_threshold.blue = 0x50;
	
	
	
	//First stage output - edge detection
	edge_detect(input_image, output_image);
	write_bitmap("1.bmp", output_image);
	
	//Second stage output - threshold				<-This stage was not needed in our tests, but it remains here incase it should prove useful later
	//threshold_image(input_image, threshold);
	//write_bitmap("2.bmp", input_image);

	//Third stage output - convert to black and white
	bw(output_image, output_image, 1);
	write_bitmap("3.bmp", output_image);
	
	//Fourth Stage Perform hough transform
	hough_image = hough(output_image, &hough_threshold);
	write_bitmap("4.bmp", hough_image);
	
	//Fifth stage output - normalize the image by finding the standard deviation and attempt to isolate the outliers (in an attempt to get more relavent hough lines)
	findStandardDeviation(hough_image);
	write_bitmap("5.bmp", hough_image);
	
	//Change hough threshold
	hough_threshold.red = 110;
	hough_threshold.green = 110;
	hough_threshold.blue = 110;	
	
	//Sixth stage output - normalize image
	normalize(hough_image, hough_image, maxValue);
	write_bitmap("6.bmp",hough_image);
	
	
	
	#ifdef DEBUG
	printf("\nMain MAX: %d", (int)maxValue->blue);
	#endif

	
	//Set Deviation - not implemented yet!
	deviation.red = 40;
	deviation.green = 40;
	deviation.blue = 40;
	
	
	
	//---Check for objects (i.e. find the blobs generated by the hough transform and analyze them)---//
	
	//Seventh stage output - mark the blobs found in the hough transfrom with alternating red/green marks
	objects = find_objects(hough_image, &hough_threshold, &deviation);
	write_bitmap("7.bmp",hough_image);
	
	
	//Simplify the number of hough lines found down to the number designated by the "-n" console argument (finds most promient lines)	<-Still being worked on!
	//simplifyObjects(objects);
	
	
	
	/*---Size Threshold---//
	for(i=1; i< MAX_NUMBER_OF_OBJECTS && objects[i].number!=0 ;i++)
	{
		if(abs(objects[i].right - objects[i].left) < size && abs(objects[i].bottom - objects[i].top) < size)
		{
			objects[i].active=0;
		}
	}*/
	
	
	
	//Eighth stage output - box the objects that were found (boxes them with blue)
	box_objects(objects, hough_image, REDUCED);
	write_bitmap("8.bmp", hough_image);
	
	

	//Final Stage output - draw the lines found by the hough transfrom onto the original image
	hough_lines(objects, input_image, hough_image->info_header.height);
	//Image is printed by the main function to the file specified by the "-o" command line argument
	
	
		
	//Free resources
	free(objects);
	
	
	
	//Return the number of objects found
	return num_objects;
}












//---Check pixel to see if it's part of an object---//
OBJECT* find_objects(IMAGE* input_image, SINGLE_PIXEL* threshold, SINGLE_PIXEL* deviation)
{
	//-------Local Vairbales-------//
	
	//Array to keep track of objects that have been found.  Size of this is designated by x, y arguments.
	unsigned int** obj;
	
	OBJECT* objects;
	
	//Number of objects
	int* objNumber;
	
	//General Purpose Variables
	int i,j,k1,k2,width,height;
	
	//No duplicates tag
	short no_dup;
	
	#ifdef DEBUG
	printf("\nFinding Objects...");
	fflush(NULL);
	#endif
	
	//Allocate space for "number of objects" variable
	objNumber = (int*)calloc(1, sizeof(int));
	
	//Set the number of objects to zero
	*objNumber = 0;
	
	//Set width and height
	width = input_image->info_header.width;
	height = input_image->info_header.height;
	
	//Allocate memory for object variable
	objects = (OBJECT*)calloc(MAX_NUMBER_OF_OBJECTS,sizeof(OBJECT));
	
	//Allocate array of pointers to keep track of pixels that have been checked
	obj = (unsigned int**)calloc(width,sizeof(unsigned int*));
	
	//Allocate the width dimention of the array of pointers to keep track of pixels that have been checked
	for(i=0; i<width; i++)
	{
		obj[i] = (unsigned int*)calloc(height,sizeof(unsigned int));
	}
	
	
	//Set the number of objects to zero
	*objNumber = 0;
	
	//Check for objects by iterating through the enire bitmap array
	for(j=0; j<height; j++)
	{
		for(i=0; i<width; i++)
		{
			if(obj[i][j]==0 && (input_image->bitmap[i][j].red >= threshold->red && input_image->bitmap[i][j].green >= threshold->green && input_image->bitmap[i][j].blue >= threshold->blue))
			{
				*objNumber+=1;
				objects[*objNumber].active=YES;
				objects[*objNumber].number=*objNumber;
				objects[*objNumber].top=j;
				objects[*objNumber].bottom=j;
				objects[*objNumber].left=i;
				objects[*objNumber].right=i;
				
				check_pixel(input_image, threshold, obj, i, j, objNumber, objects);
				
				#ifdef DEBUG
				printf("\nTOP: %.3d\tBTM: %.3d\tLFT: %.3d\tRHT: %d",objects[*objNumber].top,objects[*objNumber].bottom,objects[*objNumber].left,objects[*objNumber].right);
				#endif
			}
			
		}
	}
	
	num_objects = *objNumber;
	
	#ifdef DEBUG
	printf("Done\n\nNumber of objects found: %d",*objNumber);
	#endif
	
	//Release resources
	free(obj);
	
	
	return objects;
}











//---Check pixel to see if it's part of an object---//
int check_pixel(IMAGE* input_image, SINGLE_PIXEL* threshold, unsigned int** obj, int x, int y, int* objNumber, OBJECT* objects)
{
	short int newObject;
	
	newObject=0;

	//Check to see if the pixel has been checked before
	if(obj[x][y]!=0)
	{
		return 0;
	}
	else
	{
		//Set the "pixel checked" flag
		obj[x][y]=1;
	}
	
	
	//If the pixel has not been checked before, check to see if the pixel is above the threshold value
	if(input_image->bitmap[x][y].red >= threshold->red && input_image->bitmap[x][y].green >= threshold->green && input_image->bitmap[x][y].blue >= threshold->blue )
	{
		
		
		//Change pixel color
		if(*objNumber%2==0)
		{
			input_image->bitmap[x][y].red = 0xFF;
			input_image->bitmap[x][y].green = 0x00;
			input_image->bitmap[x][y].blue = 0x00;
		}
		else if(*objNumber%2==1)
		{
			input_image->bitmap[x][y].red = 0x00;
			input_image->bitmap[x][y].green = 0xFF;
			input_image->bitmap[x][y].blue = 0x00;
		}
		
		//-------Check surrounding pixels for existing objects-------//
		if(x>0 && obj[x-1][y]==0)
		{
			check_pixel(input_image, threshold, obj, x-1, y, objNumber, objects);
		}						
		if(x>0 && y<(input_image->info_header.height-1) && obj[x-1][y+1]==0)
		{
			check_pixel(input_image, threshold, obj, x-1, y+1, objNumber, objects);
		}
		if(y<(input_image->info_header.height-1) && obj[x][y+1]==0)
		{
			check_pixel(input_image, threshold, obj, x, y+1, objNumber, objects);
		}
		if(y<(input_image->info_header.height-1) && x<(input_image->info_header.width-1) && obj[x+1][y+1]==0)
		{
			check_pixel(input_image, threshold, obj, x+1, y+1, objNumber, objects);
		}
		if(x<(input_image->info_header.width-1) && obj[x+1][y]==0)
		{
			check_pixel(input_image, threshold, obj, x+1, y, objNumber, objects);
		}
		if(x<(input_image->info_header.width-1) && y>0 && obj[x+1][y-1]==0)
		{
			check_pixel(input_image, threshold, obj, x+1, y-1, objNumber, objects);
		}
		if(y>0 && obj[x][y-1]==0)
		{
			check_pixel(input_image, threshold, obj, x, y-1, objNumber, objects);
		}
		if(y>0 && x>0 && obj[x-1][y-1]==0)
		{
			check_pixel(input_image, threshold, obj, x-1, y-1, objNumber, objects);
		}
		
		if(objects[*objNumber].top<y)
			objects[*objNumber].top=y;
		
		if(objects[*objNumber].bottom>y)
			objects[*objNumber].bottom=y;
		
		if(objects[*objNumber].left>x)
			objects[*objNumber].left=x;
		
		if(objects[*objNumber].right<x)
			objects[*objNumber].right=x;
		
		return 1;
		
	}
		
	return 0;
}












//---Box the region of interest---//
int boxbound(int top, int bottom, int left, int right, IMAGE* input_image, SINGLE_PIXEL bndbox)
{
	//---Local Variables---//
	int i,j;
	
	//Draw top
	for(i=left; i<=right; i++)
	{
		input_image->bitmap[i][top].blue=bndbox.blue;
		input_image->bitmap[i][top].green=bndbox.green;
		input_image->bitmap[i][top].red=bndbox.red;
	}
	
	//Draw Bottom
	for(i=left; i<=right; i++)
	{
		input_image->bitmap[i][bottom].blue=bndbox.blue;
		input_image->bitmap[i][bottom].green=bndbox.green;
		input_image->bitmap[i][bottom].red=bndbox.red;
	}
	
	//Draw left
	for(j=top; j>=bottom; j--)
	{
		input_image->bitmap[left][j].blue=bndbox.blue;
		input_image->bitmap[left][j].green=bndbox.green;
		input_image->bitmap[left][j].red=bndbox.red;
	}
	
	//Draw right
	for(j=top; j>=bottom; j--)
	{
		input_image->bitmap[right][j].blue=bndbox.blue;
		input_image->bitmap[right][j].green=bndbox.green;
		input_image->bitmap[right][j].red=bndbox.red;
	}
}












//Performs x-axis and y-axis differentiation on objects to detect edges based on change in color brightness
void edge_detect(IMAGE* input_image, IMAGE* output_image)
{

	//Local Variables
	int i,j;	

	//---Perform blue X-axis differentiation---//
	for(j=0; j<input_image->info_header.height; j++)
	{
		for(i=0;i<input_image->info_header.width; i++)
		{
			//If the current pixel is the last pixel, set the output to be the zero there, and do not diffentiate it
			if(i==input_image->info_header.width-1)
			{
				output_image->bitmap[i][j].blue = 0x00;
				continue;
			}
			
			//Get the positive difference of the current pixel and the next
			if(input_image->bitmap[i][j].blue >= input_image->bitmap[i+1][j].blue)
			{
				output_image->bitmap[i][j].blue = (input_image->bitmap[i][j].blue - input_image->bitmap[i+1][j].blue);
			}
			else
			{
				output_image->bitmap[i][j].blue = (input_image->bitmap[i+1][j].blue - input_image->bitmap[i][j].blue);
			}
	
		}
	}
	
	
	//---Perform blue Y-axis differentiation---//
	for(i=0; i<input_image->info_header.width; i++)
	{
		for(j=0;j<input_image->info_header.height; j++)
		{
			//If the current pixel is the last pixel, set the output to be the zero there, and do not diffentiate it
			if(j==input_image->info_header.height-1)
			{
				output_image->bitmap[i][j].blue = 0x00;
				continue;
			}
			
			//Get the positive difference of the current pixel and the next
			if(input_image->bitmap[i][j].blue >= input_image->bitmap[i][j+1].blue)
			{
				output_image->bitmap[i][j+1].blue = output_image->bitmap[i][j+1].blue + (input_image->bitmap[i][j].blue - input_image->bitmap[i][j+1].blue);
			}
			else
			{
				output_image->bitmap[i][j].blue = output_image->bitmap[i][j+1].blue + (input_image->bitmap[i][j+1].blue - input_image->bitmap[i][j].blue);
			}
	
		}
	}	
	
	
	//---Perform Green X-axis differentiation---//
	for(j=0; j<input_image->info_header.height; j++)
	{
		for(i=0;i<input_image->info_header.width; i++)
		{
			//If the current pixel is the last pixel, set the output to be the zero there, and do not diffentiate it
			if(i==input_image->info_header.width-1)
			{
				output_image->bitmap[i][j].green = 0x00;
				continue;
			}
			
			//Get the positive difference of the current pixel and the next
			if(input_image->bitmap[i][j].green >= input_image->bitmap[i+1][j].green)
			{
				output_image->bitmap[i][j].green = (input_image->bitmap[i][j].green - input_image->bitmap[i+1][j].green);
			}
			else
			{
				output_image->bitmap[i][j].green = (input_image->bitmap[i+1][j].green - input_image->bitmap[i][j].green);
			}
	
		}
	}
	
	
	//---Perform Green Y-axis differentiation---//
	for(i=0; i<input_image->info_header.width; i++)
	{
		for(j=0;j<input_image->info_header.height; j++)
		{
			//If the current pixel is the last pixel, set the output to be the zero there, and do not diffentiate it
			if(j==input_image->info_header.height-1)
			{
				output_image->bitmap[i][j].green = 0x00;
				continue;
			}
			
			//Get the positive difference of the current pixel and the next
			if(input_image->bitmap[i][j].green >= input_image->bitmap[i][j+1].green)
			{
				output_image->bitmap[i][j+1].green = output_image->bitmap[i][j+1].green + (input_image->bitmap[i][j].green - input_image->bitmap[i][j+1].green);
			}
			else
			{
				output_image->bitmap[i][j].green = output_image->bitmap[i][j+1].green + (input_image->bitmap[i][j+1].green - input_image->bitmap[i][j].green);
			}
	
		}
	}
	
	
	
	//---Perform red X-axis differentiation---//
	for(j=0; j<input_image->info_header.height; j++)
	{
		for(i=0;i<input_image->info_header.width; i++)
		{
			//If the current pixel is the last pixel, set the output to be the zero there, and do not diffentiate it
			if(i==input_image->info_header.width-1)
			{
				output_image->bitmap[i][j].red = 0x00;
				continue;
			}
			
			//Get the positive difference of the current pixel and the next
			if(input_image->bitmap[i][j].red >= input_image->bitmap[i+1][j].red)
			{
				output_image->bitmap[i][j].red = (input_image->bitmap[i][j].red - input_image->bitmap[i+1][j].red);
			}
			else
			{
				output_image->bitmap[i][j].red = (input_image->bitmap[i+1][j].red - input_image->bitmap[i][j].red);
			}
	
		}
	}
	
	
	//---Perform red Y-axis differentiation---//
	for(i=0; i<input_image->info_header.width; i++)
	{
		for(j=0;j<input_image->info_header.height; j++)
		{
			//If the current pixel is the last pixel, set the output to be the zero there, and do not diffentiate it
			if(j==input_image->info_header.height-1)
			{
				output_image->bitmap[i][j].red = 0x00;
				continue;
			}
			
			//Get the positive difference of the current pixel and the next
			if(input_image->bitmap[i][j].red >= input_image->bitmap[i][j+1].red)
			{
				output_image->bitmap[i][j+1].red = output_image->bitmap[i][j+1].red + (input_image->bitmap[i][j].red - input_image->bitmap[i][j+1].red);
			}
			else
			{
				output_image->bitmap[i][j].red = output_image->bitmap[i][j+1].red + (input_image->bitmap[i][j+1].red - input_image->bitmap[i][j].red);
			}
	
		}
	}
	
	return;
	
}












/*multiply_image functino
 *
 * You can use this function to multiply the brighness of an image.
 *
 */
void multiply_image(IMAGE* input_image, SINGLE_PIXEL* multiplier)
{
	int i,j,k;

	//---Perform Mutlipy---//
	for(j=0; j<input_image->info_header.height; j++)
	{
		for(i=0;i<input_image->info_header.width; i++)
		{
		
			if(input_image->bitmap[i][j].blue * multiplier->blue < 0xFF)
				input_image->bitmap[i][j].blue = input_image->bitmap[i][j].blue * multiplier->blue;
			else input_image->bitmap[i][j].blue = 0xFF;
			
			if(input_image->bitmap[i][j].green * multiplier->green < 0xFF)
				input_image->bitmap[i][j].green = input_image->bitmap[i][j].green * multiplier->green;
			else input_image->bitmap[i][j].green = 0xFF;
			
			if(input_image->bitmap[i][j].red * multiplier->red < 0xFF)
				input_image->bitmap[i][j].red = input_image->bitmap[i][j].red * multiplier->red;
			else input_image->bitmap[i][j].red = 0xFF;
								
		}
	}
	
	return;
	
}












//Performs a threshold calculation on an image given a threahold value
void threshold_image(IMAGE* input_image, SINGLE_PIXEL* threshold)
{
	int i,j;

	//---Perform Threshold---//
	for(j=0; j<input_image->info_header.height; j++)
	{
		for(i=0;i<input_image->info_header.width; i++)
		{
		
			//Blue Threshold
			if(input_image->bitmap[i][j].blue > threshold->blue)
			{
				input_image->bitmap[i][j].blue=0xFF;
			}
			else
			{
				input_image->bitmap[i][j].blue=0x00;
			}
			
			//Green Threshold
			if(input_image->bitmap[i][j].green > threshold->green)
			{
				input_image->bitmap[i][j].green=0xFF;
			}
			else
			{
				input_image->bitmap[i][j].green=0x00;
			}
			
			//Red Threshold
			if(input_image->bitmap[i][j].red > threshold->red)
			{
				input_image->bitmap[i][j].red=0xFF;
			}
			else
			{
				input_image->bitmap[i][j].red=0x00;
			}
					
		}
	}
	
	return;
}












//Combine two objects
void combine_objects(int obj1, int obj2, OBJECT* objects)
{
	//Local variables
	
	//General purpose variables
	int i, j;

	//printf("\nFound overlap on objects:%d\tand\t%d",obj1,obj2);

	//combine the higher numbered object into the lower numbered one
	if(obj1 < obj2)
	{
		//Merge larger object into the lower nmbered one
		if(objects[obj2].left < objects[obj1].left)
			objects[obj1].left = objects[obj2].left;
		
		if(objects[obj2].right > objects[obj1].right)
			objects[obj1].right = objects[obj2].right;
			
		if(objects[obj2].top < objects[obj1].top)
			objects[obj1].top = objects[obj2].top;
		
		if(objects[obj2].bottom > objects[obj1].bottom)
			objects[obj1].bottom = objects[obj2].bottom;
			
		//Invaidate the larger numbered object
		objects[obj2].active = NO;
	}
	else
	{
		//Merge larger object into the lower nmbered one
		if(objects[obj1].left < objects[obj2].left)
			objects[obj2].left = objects[obj1].left;
		
		if(objects[obj1].right > objects[obj2].right)
			objects[obj2].right = objects[obj1].right;
			
		if(objects[obj1].top < objects[obj2].top)
			objects[obj2].top = objects[obj1].top;
		
		if(objects[obj1].bottom > objects[obj2].bottom)
			objects[obj2].bottom = objects[obj1].bottom;
			
		//Invaidate the larger numbered object
		objects[obj1].active = NO;
	}
	
				
		
	return;
}











//Changes a color input image into a black and white image
//mode: 0 for black and white, 1 for grey-scale
void bw(IMAGE* input_image, IMAGE* output_image, int mode)
{
	//Local variables
	int i, j;
	
	//Temp average color
	unsigned char temp;
	
	if(mode==0)
	{
		for(j=0; j<input_image->info_header.height; j++)
		{
			for(i=0;i<input_image->info_header.width; i++)
			{
			
				if(input_image->bitmap[i][j].blue > 0)
				{
					output_image->bitmap[i][j].blue = 0xFF;
					output_image->bitmap[i][j].green = 0xFF;
					output_image->bitmap[i][j].red = 0xFF;
				}
				
				if(input_image->bitmap[i][j].green > 0)
				{
					output_image->bitmap[i][j].blue = 0xFF;
					output_image->bitmap[i][j].green = 0xFF;
					output_image->bitmap[i][j].red = 0xFF;
				}
					
				if(input_image->bitmap[i][j].red > 0)
				{
					output_image->bitmap[i][j].blue = 0xFF;
					output_image->bitmap[i][j].green = 0xFF;
					output_image->bitmap[i][j].red = 0xFF;
				}
				
			}
		}
	}
	else
	{
		for(j=0; j<input_image->info_header.height; j++)
		{
			for(i=0;i<input_image->info_header.width; i++)
			{
			
				/*if(input_image->bitmap[i][j].red >= input_image->bitmap[i][j].green && input_image->bitmap[i][j].red >= input_image->bitmap[i][j].blue)
				{
					temp = input_image->bitmap[i][j].red;
				}
				else if(input_image->bitmap[i][j].green >= input_image->bitmap[i][j].red && input_image->bitmap[i][j].green >= input_image->bitmap[i][j].blue)
				{
					temp = input_image->bitmap[i][j].green;
				}
				else
				{
					temp = input_image->bitmap[i][j].blue;
				}*/
				
				temp = (input_image->bitmap[i][j].red + input_image->bitmap[i][j].green + input_image->bitmap[i][j].blue)/3;
				
				output_image->bitmap[i][j].red = temp;
				output_image->bitmap[i][j].green = temp;
				output_image->bitmap[i][j].blue = temp;				
			}
		}
	}
}












//Output the data for a histagram
unsigned char histogram(IMAGE* input_image)
{
	//Local variables
	int i,j,k,dev,x,y,max;
	
	//Threshold
	unsigned char threshold;
	
	//Standard Deviation
	double sta_dev;
	
	//Average value
	double avg;
	
	//File pointer
	FILE* fp;
	
	//Histagram IMAGE
	IMAGE* hist;
	
	//Average color
	int temp;
	
	//Array to hold the number of pixels with n brightness.
	unsigned int intensity[256];
	
	for(i=0; i<256; i++)
	{
		intensity[i]=0;
	}
	
	//Clear the standard deviation
	sta_dev=0;
	
	//Clear the Average
	avg = 0;
	
	//Clear the max
	max = 0;
	
	//Clear threshold
	threshold = 0;
	
	//Set x and y variables
	x = input_image->info_header.width;
	y = input_image->info_header.height;
	
	//Find the attributes of the image
	for(j=0; j<y; j++)
	{
		for(i=0;i<x; i++)
		{
			
			//Assign the temp value
			temp = (int)(input_image->bitmap[i][j].green);// + input_image->bitmap[i][j].green + input_image->bitmap[i][j].blue)/3;
			
			//Sum all the values
			avg+=temp;
						
			//Only incriment non-zero values
			if(temp!=0)	intensity[temp]+=1;
		}
	}
	
	//Devide by total number of pixels to get the average value
	avg = (avg/(x*y));
	
	//Calculate standard deviation
	for(j=0; j<y; j++)
	{
		for(i=0;i<x; i++)
		{
			temp = (int)(input_image->bitmap[i][j].green);
			
			if(temp!=0) sta_dev += ((temp - avg)*(temp - avg));
		}
	}
	
	//Finish calculating standard deviation
	sta_dev = sqrt(sta_dev);
	
	
	
	//Find the max number of pixels at any one intensity level
	for(i=0; i<255; i++)
	{
		if(intensity[i] > max) max = intensity[i];
	}
	
	
	
	//Calculate minimum threshold value
	threshold = (unsigned char)(max/600);	
	
#ifdef DEBUG	
	printf("\n\nStandard Deviation: %f", sta_dev);
	printf("\nMax: %d", max);
	printf("\nThreshold: %d", threshold);
	fflush(NULL);
#endif
	
	dev=1;
	
	//Open the file
	fp = fopen("histogram.txt", "w");
		
	for(i=0; i<256; i++)
	{
		k=0;
	
		for(j=i; j<i+dev; j++)
		{
			k+=intensity[j];
		}

#ifdef DEBUG
		fprintf(fp, "%d,%u\n",i,k);
#endif
	}
	
	fclose(fp);
	
	
	//Return the appropriate hough threshold value
	return threshold;
			
}












//Perform hough transform on image
IMAGE* hough(IMAGE* input_image, SINGLE_PIXEL* threshold)
{

	//-------Local variables-------//
	int i,j,k,x,y,pixel_temp;
	
	int b1, b2, x1, x2, y1, y2, length, x_intersection, y_intersection, temp, x_midpoint, y_midpoint, bounce_flag;
	
	float m1, m2, theta, alpha;
	
	//Lookup table for various images: row 0 is theta, row 1 is m1, row 2 is m2, and row 3 is alpha
	float** lookup;
	
	//hough transform image
	IMAGE* htrans;
	
	
	
	//Set x and y variables for easier code reading
	
	//X = image width
	x = input_image->info_header.width;
	
	//Y = Image height
	y = input_image->info_header.height;
	
	//Calculate the center of the image
	x_midpoint = (input_image->info_header.width)/2;
	y_midpoint = (input_image->info_header.height)/2;
	
	//Allocate memory for the image struct
	htrans = (IMAGE*)calloc(1,sizeof(IMAGE));
	
	//Allocate memory for the frist row of the lookup table
	lookup = (float**)calloc(HOUGH_ANGLE*SAMPLES_PER_UNIT, sizeof(float*));
		
	//Allocate memory for the other rows of the lookup table
	for(i=0; i< (HOUGH_ANGLE*SAMPLES_PER_UNIT); i++)
	{
		lookup[i] = (float*)calloc(4, sizeof(float));
	}
	
	
	
	//Allocate memory for x-asix of the bitmap
	htrans->bitmap = (SINGLE_PIXEL**)calloc((int)(HOUGH_ANGLE*SAMPLES_PER_UNIT), sizeof(SINGLE_PIXEL*));
	
	//Allocate memory for the y-axis of the bitmap
	for(i=0; i<(HOUGH_ANGLE*SAMPLES_PER_UNIT); i++)
	{
		htrans->bitmap[i] = (SINGLE_PIXEL*)calloc((int)sqrt(x*x+y*y),sizeof(SINGLE_PIXEL));
	}
	
	
	
	//Set image size in it's header, this allows the function "write_bitmap" to properly write the image to a file.
	htrans->info_header.width = (HOUGH_ANGLE*SAMPLES_PER_UNIT);
	htrans->info_header.height = (int)sqrt(x*x+y*y);
	
	
	#ifdef DEBUG
	printf("\n\nCalculating Hough Transform...");
	fflush(NULL);
	#endif
	
	
	//-------Acutally Calculate the hough transform-------//
	
	//Iterate through all the rows of the image
	for(j=0; j<input_image->info_header.height; j++)
	{
		//For every row, iterage through every pixel in that row
		for(i=0; i<input_image->info_header.width; i++)
		{
			//Check to see if the pixel being checked is above the given threshold
			if(input_image->bitmap[i][j].blue >threshold->blue || input_image->bitmap[i][j].green > threshold->green || input_image->bitmap[i][j].red > threshold->red)
			{
				//For every pixel that is above threshold, calculate n=((360/HOUGH_ANGLE)*SAMPLES_PER_UNIT) lines.
				//For every n'th line, calculate the angle and radius of a line that is perpendicular to the n'th line that also intersects the midpoint of the image.
				for(theta=0; theta<HOUGH_ANGLE; theta+=(1.0f/SAMPLES_PER_UNIT))
				{
				
					//Calculate the length of the tangent line
					length = (int)(((i - x_midpoint)*cos(theta*PI/180) + (j - y_midpoint)*sin(theta*PI/180)));	
					
					//Scale max angle to match the width of the hough transform image
					alpha = (int)(theta*SAMPLES_PER_UNIT);
					
					if(length!=0)
					{
			
						//If "HIGH" is defined, map the data to a 24-bit integer and split the data up over 3 8-bit channels like so: bits [23-16][15-8][7-0] = [RED][GREEN][BLUE]
						//This method has a maximum resolution of 16,777,216.  See note in "LOW" method below.

						#ifdef HIGH
						pixel_temp = ( ((int)htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].red<<16) + ((int)htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].green<<8) + ((int)htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].blue) );
						
						pixel_temp+=INTENSITY_ADDED;
										
						htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].red = ((pixel_temp>>16)&(0xFF));
						htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].green = ((pixel_temp>>8)&(0xFF));
						htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].blue = (pixel_temp&0xFF);
						#endif
						
						
						#ifdef LOW																												
						//If "LOW" is defined, fill the blue channel until it reaches capacity, then fill the green channel until it reaches capacity, then fill the red channel until it reaches capacity, at that point the max value has been achieved and higher numbers are truncated.
						//This method has a maximum resolution of 765, but looks very pretty.
						//NOTE: In reality, the hough transform will seldom breach 756.
						if(0xFF - htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].blue >= INTENSITY_ADDED)
						{
							htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].blue += INTENSITY_ADDED;
						}
						else if(0xFF - htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].green >= INTENSITY_ADDED)
						{
							htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].blue = 0xFF;
							htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].green += INTENSITY_ADDED;
						}
						else if(0xFF - htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].red >= INTENSITY_ADDED)
						{
							htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].blue = 0xFF;
							htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].green = 0xFF;
							htrans->bitmap[(int)alpha][(htrans->info_header.height/2)+length].red += INTENSITY_ADDED;
						}
						#endif
						
					}
				}
				
			}
		}
	}
	
	#ifdef DEBUG
	printf("Done");
	fflush(NULL);
	#endif
	
	return htrans;
	
}












//Box all objects in input array
void box_objects(OBJECT* objects, IMAGE* input_image, int selection)
{
	//Local variables
	int i;
	
	//Bounding Box Color
	SINGLE_PIXEL bndbox;

	//Check to see if all, or just the reduced set, of objects are to be boxed
	if(selection!=0)
	{
		//---Box all objects of interests---//
		//Because we're boxing a lot of objects, alternate between red/green/blue boxing colors
		for(i=1; i< MAX_NUMBER_OF_OBJECTS && objects[i].number>0; i++)
		{
			//Set bounding box color
			if((i-1)%3 == 0)
			{
				bndbox.red = 0xFF;
				bndbox.green = 0x00;
				bndbox.blue = 0x00;
			}
			else if((i-1)%3 == 1)
			{
				bndbox.red = 0x00;
				bndbox.green = 0xFF;
				bndbox.blue = 0x00;
			}
			else if((i-1)%3 == 2)
			{
				bndbox.red = 0x00;
				bndbox.green = 0x00;
				bndbox.blue = 0xFF;
			}
			else
			{
				bndbox.red = 0xFF;
				bndbox.green = 0x00;
				bndbox.blue = 0xFF;
			}			
		
			boxbound(objects[i].top, objects[i].bottom, objects[i].left, objects[i].right, input_image, bndbox);
		}
	}
	else
	{	
		
		//Set boudning box color
		bndbox.red = 0x00;
		bndbox.green = 0x00;
		bndbox.blue = 0xFF;
		
		//Iterate through records and box appropriate objects
		for(i=1; i<MAX_NUMBER_OF_OBJECTS && objects[i].number>0; i++)
		{			
			if(objects[i].active==1)
			{
				boxbound(objects[i].top, objects[i].bottom, objects[i].left, objects[i].right, input_image, bndbox);
			}
			else 
			{
				num_objects--;
			}
		}
	}

	
	
	return;
}












void hough_lines(OBJECT* objects, IMAGE* input_image, int max_radius)
{
	//Local variables
	int i, j, k, n, x1, x2;
	float radius, alpha;
	
	//Iterate through records and draw appropriate lines
	for(k=1; k<MAX_NUMBER_OF_OBJECTS && objects[k].number>0; k++)
	{
		if(objects[k].active==1)
		{
			//Get average angle
			alpha = ((objects[k].left + objects[k].right)/2)/SAMPLES_PER_UNIT;

			//Get average radius
			radius = ((((objects[k].top + objects[k].bottom)/2)-(max_radius/2)));

			//Draw the line
			for(j=-(int)(input_image->info_header.height); j<(int)(input_image->info_header.height); j++)
			{
				i = (int)(radius - ((j)*sin(alpha*PI/180)))/(cos(alpha*PI/180)) + (input_image->info_header.width/2);
				
				//Set right bound
				x2 = (int)(radius - ((j+1)*sin(alpha*PI/180)))/(cos(alpha*PI/180)) + (input_image->info_header.width/2);
				
				if(i>0 && i<input_image->info_header.width && (j+input_image->info_header.height/2)>0 && (j+input_image->info_header.height/2)<input_image->info_header.height)				
				{
					input_image->bitmap[i][(j+input_image->info_header.height/2)].red = 0xFF;
					input_image->bitmap[i][(j+input_image->info_header.height/2)].green = 0x00;
					input_image->bitmap[i][(j+input_image->info_header.height/2)].blue = 0x00;
					
					//Fill in the pixels along the x-axis
					if(i<x2)
					{
						for(n=i; n<=x2; n++)
						{
							if(n>0 && n<input_image->info_header.width && (j+input_image->info_header.height/2)>0 && (j+input_image->info_header.height/2)<input_image->info_header.height)				
							{
								input_image->bitmap[n][(j+input_image->info_header.height/2)].red = 0xFF;
								input_image->bitmap[n][(j+input_image->info_header.height/2)].green = 0x00;
								input_image->bitmap[n][(j+input_image->info_header.height/2)].blue = 0x00;
							}
						}
					}
					else
					{
						for(n=i; n>=x2; n--)
						{
							if(n>0 && n<input_image->info_header.width && (j+input_image->info_header.height/2)>0 && (j+input_image->info_header.height/2)<input_image->info_header.height)				
							{
								input_image->bitmap[n][(j+input_image->info_header.height/2)].red = 0xFF;
								input_image->bitmap[n][(j+input_image->info_header.height/2)].green = 0x00;
								input_image->bitmap[n][(j+input_image->info_header.height/2)].blue = 0x00;
							}
						}
					}
				}
				
			}
			
		}

	}
	
	return;
}











void normalize(IMAGE* input_image, IMAGE* output_image, SINGLE_PIXEL* maxValue)
{
	
	//---Local variables---//
	int x,y;
	int i,j;
	int max;
	
	int temp;
	
	//Set local parameters
	x = input_image->info_header.width;
	y = input_image->info_header.height;
	
	max=0;
	
	//Find maximum values
	
	for(j=0; j<y; j++)
	{
		for(i=0; i<x; i++)
		{
			
			temp = ( ((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) );		

			if(temp > max)
				max = temp;
		}
	}
	
	#ifdef DEBUG
	printf("\nMAX: %d\n", max);
	#endif

	for(j=0; j<y; j++)
	{
		for(i=0; i<x; i++)
		{
			//Calculate current value
			
			temp = ( ((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) );
			
			#ifdef DEBUG
			//printf("\nTEMP: %d", temp);  <-This printf is really annoying...
			#endif
			
			//Normalize current value
			temp = ((float)temp/(float)max)*100;
			
			//Redraw image
			input_image->bitmap[i][j].red = (char)((float)temp*2.55);
			input_image->bitmap[i][j].green =(char)((float)temp*2.55);
			input_image->bitmap[i][j].blue = (char)((float)temp*2.55);
		}
	}
	
	return;
		
	
}








int findStandardDeviation(IMAGE* input_image)
{

	int i,j;
	float sum;
	float avg;
	int temp;
	int sd;
	
	i=0;
	j=0;
	sum=0.0;
	avg=0.0;
	
	//Find average
	for(j=0; j<input_image->info_header.height; j++)
	{
		
		for(i=0; i<input_image->info_header.width; i++)
		{
			
			#ifdef HIGH
			sum += (float)( ((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) );
			#endif
			
			#ifdef LOW
			sum += (float)(((int)input_image->bitmap[i][j].red + (int)input_image->bitmap[i][j].green + (int)input_image->bitmap[i][j].blue));
			#endif
			
		}
		
	}
	
	avg = (float)((float)sum/(float)(input_image->info_header.height*input_image->info_header.width));
	
#ifdef DEBUG
	printf("\n\nAverage = %f",avg);
#endif	

	sum=0;
	
	//Calculate standard deviation
	for(j=0; j<input_image->info_header.height; j++)
	{
		
		for(i=0; i<input_image->info_header.width; i++)
		{
			
			#ifdef HIGH
			temp = ((((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) )-avg)*((((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) )-avg);
			#endif
			
			#ifdef LOW
			temp =  ((float)(((float)input_image->bitmap[i][j].red + (float)input_image->bitmap[i][j].green + (float)input_image->bitmap[i][j].blue))-avg)*((float)(((float)input_image->bitmap[i][j].red + (float)input_image->bitmap[i][j].green + (float)input_image->bitmap[i][j].blue))-avg);
			#endif
			
			sum=sum+temp;
			
			input_image->bitmap[i][j].red = ((temp>>16)&(0xFF));
			input_image->bitmap[i][j].green = ((temp>>8)&(0xFF));
			input_image->bitmap[i][j].blue = (temp&0xFF);
			
		}
		
		
	}
	
	sd = sqrt(sum/(float)(input_image->info_header.height*input_image->info_header.width));
	write_bitmap("9.bmp",input_image);

	
	//Redraw hough transform with standard deviation calculation
	for(j=0; j<input_image->info_header.height; j++)
	{
		
		for(i=0; i<input_image->info_header.width; i++)
		{
			
			temp = (((((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) )-(avg+(sd/2)))<0?0:((((int)input_image->bitmap[i][j].red<<16) + ((int)input_image->bitmap[i][j].green<<8) + ((int)input_image->bitmap[i][j].blue) )-(avg+(sd/2))));
			
			input_image->bitmap[i][j].red = ((temp>>16)&(0xFF));
			input_image->bitmap[i][j].green = ((temp>>8)&(0xFF));
			input_image->bitmap[i][j].blue = (temp&0xFF);
			
		}
		
	}
	
#ifdef DEBUG
	printf("\nStandard Deviation: %d",sd);
#endif
	
	return sd;
	
}







void simplifyObjects(OBJECT* objects)
{
	int i,j,k;
	OBJECT* current;
	
	for(k=1; k<MAX_NUMBER_OF_OBJECTS && objects[k].number>0; k++)
	{
		if(objects[k].active==1)
		{
			current = &objects[k];
#ifdef DEBUG
			printf("\n\n");
#endif
			
			for(j=1; j<MAX_NUMBER_OF_OBJECTS && objects[j].number>0; j++)
			{
				if(j!=k)	//make sure we don't compare the object to itself
				{
					
					if((objects[j].right-objects[j].left)-1<=(current->right-current->left) || (objects[j].right-objects[j].left)+1>=(current->right-current->left))
					{
#ifdef DEBUG
						printf("\nX1: %d\tX2: %d",(current->right-current->left),(objects[j].right-objects[j].left));
#endif
						combine_objects(j,k,objects);
					}
					
				}
				
			}
			
		}
		
	}
			
			
	
	return;
}



























