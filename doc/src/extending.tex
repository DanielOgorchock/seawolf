
\newpage
\section{Extending the Seawolf Software Stack} \label{extending}
\subsection{Adding SeaSQL Variables} \label{extendingseasql}
Unfortunately, in order to provide easy to use set and get functions for
accessing SeaSQL variables, the set of SeaSQL variables must be hard-coded as
part of SeaSQL and \libseawolf{}. Fortunately however, adding SeaSQL variables
is an easy process, needing only basic changes to two source files in
\libseawolf{}. Relative to the \folder{seawolf3/libseawolf} directory (see
\interlink{environment}{The Environment}), the pertinent source files are
\file{include/seawolf/seasql.h} and \file{src/seasql.c}. In \file{seasql.c},
after the includes is a block which looks like
\begin{lstlisting}[language=Cextended, escapeinside={{*@}{@*}}, firstnumber=16]
   *@ \ldots{} @*
/* Define all variables and accessors */
MYSQL_ACCESSOR( Aft )
MYSQL_ACCESSOR( BowPort )
MYSQL_ACCESSOR( BowStar )
MYSQL_ACCESSOR( Depth )
   *@ \ldots{} @*
\end{lstlisting}
Adding a new variable is as simple as copying the form seen here and replacing
the existing variable (Aft, BowPort, Depth, etc.) with the ones to be added. In
\file{seasql.h} a similar pattern exists
\begin{lstlisting}[language=Cextended, escapeinside={{*@}{@*}}, firstnumber=26]
   *@ \ldots{} @*
/* Define all variables and accessors */
MYSQL_ACCESSOR_HEADER( Aft )
MYSQL_ACCESSOR_HEADER( BowPort )
MYSQL_ACCESSOR_HEADER( BowStar )
MYSQL_ACCESSOR_HEADER( Depth )
   *@ \ldots{} @*
\end{lstlisting}
Again, simply copy an existing line and replace the variable name. After these
changes, \libseawolf{} will need to be recompiled (see
\interlink{buildusing}{Using the Build System}) and redistributed to all
users.

\subsection{Extended Database Access} \label{extendingdb}
SeaSQL is a very specialized interface to the backing database but extension
mechanisms do exist for more general and low level database access. Currently
this support is minimal but SeaSQL does expose a single function,
\inlinelink{extendingdbexecute}{\func{SeaSQL\_execute}} to execute raw SQL
expressions on the database.

\subsubsection{SeaSQL\_execute} \label{extendingdbexecute}
\cdoc{int SeaSQL_execute(char* cmd)} Execute a single SQL expression, passed as
\texttt{cmd} and execute it on the backing database. Returned is the error
status of the execution. The value 0 designates no error.

\subsection{Creating new \libseawolf{} Components} \label{extendingcomponents}
Creating new \libseawolf{} components is a fairly simple matter. The overall
integration of the codebase isn't excessive so introducing new code is
easy. When writing your extension you can use \libseawolf{} as if you were
developing a standard application, all of its functions and features are
available to you; just include the correct headers and the rest is handled for
you.

\subsubsection{Required Files} \label{extendingcomponentsfiles}
The source file for your component will reside in
\file{src/\bracket{your component}.c}
and its corresponding header file will be \file{include/seawolf/\bracket{your component}.h}.

\subsubsection{Sematics and Structure} \label{extendingcomponentssemantics}
\libseawolf{} has no strictly enforcable rules for structure or semantics, but
many of these rules have developed through their consistent use and these rules
should be taken into account when expanding \libseawolf{}. 

\paragraph{Function and Variable Naming}
The naming semantics for \libseawolf{} are mostly flexible with only a few basic
rules. Functions names should follow the follow conventions: the component name
is prefixed to the function name with an underscore as a separator and the
actual function name should be in camel case, an example
\hfill\vspace{8pt}\newline \indent\cdefine{void MyComponent_getTheValue(int
  some_name);}
\vspace{8pt}\newline
As you can also see with this example, underscores are used in variable names.

\paragraph{Required Methods}
While a component's set of functions will be dependant on the component's needs,
each component should define two standard functions. These are 
\hfill\vspace{8pt}\newline
\indent\cdefine{void MyComponent_init(void)} and \cdefine{void MyComponent_close(void)}
\vspace{8pt}\newline where MyComponent is the name of the component you are
writing. These functions are called by the global
\inlinelink{apiseawolfinit}{\func{Seawolf\_init}} and
\inlinelink{apiseawolfclose}{\func{Seawolf\_close}} functions and should be
present, even if empty, for the sake of consistency. When actually utilized they
are responsible for performing any startup or initialization work and shutdown
operations respectively.

\paragraph{Component State}
\libseawolf{} is designed to be accessible and easy to use. It was decided early
on that little would be gained from entrusting the end programmer with
maintaining the data structures necessary to track program state. Therefore,
each component maintains its own private set of variables global to the
components as a whole. As one might imagine however, this can be an issue if the
programmer desired to have multiple, logically separate, SeaSQL interfaces each
connected to a different database, for instance. In this case, \libseawolf{}
would have to pass off structures to the programmer for each SeaSQL instance and
leave it up to the end programmer to pass back the correct one each time. This
kind of functionality isn't needed for Seawolf's applications however so
\libseawolf{} acts as a single, static instance that uses global variables to
track state.  This greatly reduces the complexity from both the application and
\libseawolf{} programmer's perspective. When using global variables in your own
components, insure that they are statically declared so that they are accessible
only from within the given file. Refer to existing code as documentation of
these practices.

\paragraph{Header File}
The simplest method for constructing an appropriate header file is to copy the
structure from an existing \libseawolf{} header file in
\folder{include/seawolf} and change parts as
necessary. Other than obviously changing the function declarations to match your
component's public methods, you should also strip out unnecessary includes and
change the outline of the file to reflect your component. The outline of the
header for SeaSQL looks like this,
\begin{lstlisting}[language=Cextended, caption=seasql.h outline, escapeinside={{*@}{@*}}]
#ifndef __SEAWOLF_SEASQL_INCLUDE_H
#define __SEAWOLF_SEASQL_INCLUDE_H
  *@\ldots{}@*
#endif // #ifndef __SEAWOLF_SEASQL_INCLUDE_H
\end{lstlisting}
so if you are writing a component called MyComponent then the outline should be modified to read 
\begin{lstlisting}[language=Cextended, caption=mycomponent.h outline, escapeinside={{*@}{@*}}]
#ifndef __SEAWOLF_MYCOMPONENT_INCLUDE_H
#define __SEAWOLF_MYCOMPONENT_INCLUDE_H
  *@\ldots{}@*
#endif // #ifndef __SEAWOLF_MYCOMPONENT_INCLUDE_H
\end{lstlisting}
These lines are important and keep a header from being included more than once
in a given source file. If you don't do this, it is likely that the library and
applications will fail to build.

\subsubsection{Integrating}
Changes to two existing files will be necessary to finalize the integration
process for your component. First open \file{include/seawolf.h} and add an
include statement for your new component as has been done with existing
components. This will allow the end programmer to make use of your component by
simply including \file{seawolf.h}. Now open \file{src/main.c}; in the
\inlinelink{apiseawolfinit}{\func{Seawolf\_init}} function body you will need to
add a call to your component's init function along side the others. Take care
that you place your init call so that any components your component depends on
will be initialized before your own. Also add a call to your component's close
function in the \inlinelink{apiseawolfclose}{\func{Seawolf\_close}} function
body. Function calls to component close methods are in reverse order of their
init calls in \inlinelink{apiseawolfinit}{\func{Seawolf\_init}}.

\subsubsection{Adding to the Build System}
In \file{src/Makefile} find the definition given as
\begin{lstlisting}[language=Cextended, caption=src/Makefile, escapeinside={{*@}{@*}}]
  *@\ldots{}@*
LIB_SRC= ardcomm.c logging.c main.c notify.c pid.c \
	seasql.c seasql_config.c seawolf_config.c \
	serial.c stack.c task.c timer.c util.c
  *@\ldots{}@*
\end{lstlisting}
Add the name of the new component to the list of source files and it will be included in the build process.

\subsection{Adding Support for New Serial Devices}
\textit{This section yet to be compeleted}
